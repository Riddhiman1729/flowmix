---
---
title: "New Response Calculation ETC"
author: "Riddhiman Bhattacharya"
date: "2025-10-14"
output: html_document
---

#Preamble
```{r}
library(mvtnorm)
```

#New Response Generation




```{r}

#' Computing the new responses conditioned on the observed censoring.
#'@param y response list containing the censored responses. List containing TT elements with each element as a matrix of size ntxdim.
#'@param X the matrix of covariates with dimensions tt x d.
#'@param censor_indicator_left A list checking whether an observation is left censored. The list if of size TT with each entry being a ntxdim  matrix.
#'@param censor_indicator_right A list checking whether an observation is right censored. The list if of size TT with each entry being a ntxdim  matrix.
#'@param cens_lim_l_vec Lower censoring limits.
#'@param cens_lim_u_vec Upper censoring limits.
#'@param numclust number of clusters
#'@param mu_list list of means by cluster. Each cluster has a matrix of dim TT x d.
#'@param sigma_list list of covariance matrices by cluster. Each cluster has a matrix of dim d x d.
#'
#'@return a nested list containing the responses per time point,observation,cluster in that order of nesting.


Estep_y <- function(y, X, censor_indicator_left, 
                             censor_indicator_right, cens_lim_l_vec, 
                             cens_lim_u_vec, numclust, mu_list,sigma_list){
  
  ##Basic Checks
  stopifnot(is.list(y))
  stopifnot(is.list(censor_indicator_left))
  stopifnot(is.list(censor_indicator_right))
  stopifnot(is.list(mu_list))
  stopifnot(is.list(sigma_list))
  stopifnot(length(cens_lim_l_vec)==length(cens_lim_u_vec))
  
  ##Main Body
  TT = length(y)
  dimdat = ncol(y[[1]])
  ntlist = sapply(y,nrow)
  out_list=list()
  out_list$new_responses = list()
  out_list$means = list()
  out_list$second_moments = list()

  
#debug(cens_cond_normal)  
res_list <- lapply(1:TT, function(tt) {
#  print(tt)
  lapply(1:ntlist[tt], function(ii) {
    res <- cens_cond_normal(ii, tt, y, X, 
                            censor_indicator_left, censor_indicator_right, 
                            cens_lim_l_vec, cens_lim_u_vec, 
                            numclust, mu_list, sigma_list)
    list( new_responses = res$new_response_list,
          mean = res$all_conditional_means,
         second_moment = res$all_conditional_second_moment_list)
#    print(ii)
  })
})

censored_y_out <- lapply(res_list, function(tt) lapply(tt, `[[`, "new_responses"))
censored_means_out <- lapply(res_list, function(tt) lapply(tt, `[[`, "mean"))
censored_second_moment_out <- lapply(res_list, function(tt) lapply(tt, `[[`, "second_moment"))

out_list$new_responses <- lapply(1:numclust, function(iclust) {
  lapply(1:TT, function(tt) {
    # pick iclust-th component from each ii in this time tt
    pieces <- lapply(censored_y_out[[tt]], function(ii_elem) ii_elem[[iclust]])
    sapply(pieces, cbind)
  })
})

out_list$means <- lapply(1:numclust, function(iclust) {
  lapply(1:TT, function(tt) {
    # pick iclust-th component from each ii in this time tt
    pieces <- lapply(censored_means_out[[tt]], function(ii_elem) ii_elem[[iclust]])
    sapply(pieces, cbind)
  })
})

out_list$second_moments <- lapply(1:numclust, function(iclust) {
  lapply(1:TT, function(tt) {
    pieces <- lapply(censored_second_moment_out[[tt]], function(ii_elem) ii_elem[[iclust]])
    simplify2array(pieces)
  })
})
  
new_response_list = lapply(out_list$new_responses, function(iclust){
  lapply(iclust,function(tt){
    if (is.list(tt)) {
      t(do.call(rbind, tt))
    } else {
      # If it's already a matrix, return as is or handle appropriately
      if (is.matrix(tt)) {
        t(tt)
      } else {
        # If it's a vector, make it a 1-row matrix
        matrix(tt, nrow = 1)
      }
    }
  })
})

  return(list(new_responses = new_response_list,
              means = out_list$means,
              second_moments = out_list$second_moments))
}

#debug(Estep_y)

#Estep_y(y=ylist,X,censor_indicator_left=cens_ind_left, 
#                             censor_indicator_right=cens_ind_right, cens_lim_l_vec=cens_vec_1, 
#                             cens_lim_u_vec=cens_vec_2, numclust=2, mu_list = mn_list ,sigma_list = Sig_list)




```


```{r}

numclust=2


pmat=matrix(NA, TT, numclust)

for(iclust in 1:numclust){
pmat[1:(TT/2+iclust),iclust]=1/2
pmat[(TT/2+iclust+1):TT,iclust]=1/3
}

mn_array = simplify2array(mn_list)
sigma_array = aperm(simplify2array(Sig_list), perm=c(3,1,2))

```


```{r}
library('Rcpp')
sourceCpp('C://Users//16128//Documents//Sangwon_Project//Codes//dmvnorm.cpp')
##' Calculates the $k$'th ratio of the (pi * density) of every datapoint,
##' compared to the sum over all clusters k=1:K. These are called responsibilities (a
##' posterieri membership probabilities).
##'
##' @param prob Matrix of component weights.
##' @param ylist Data.
##' @param mn Array of all means.
##' @param sigma (numclust x dimdat x dimdat) array.
##'@param censor_indicator_left A list checking whether an observation is left censored. The list if of size TT with each entry being a ntxdim  matrix.
#'@param censor_indicator_right A list checking whether an observation is right censored. The list if of size TT with each entry being a ntxdim  matrix.
#'@param cens_lim_l_vec Lower censoring limits.
#'@param cens_lim_u_vec Upper censoring limits.
##' @param numclust Number of clusters.
##' @param eps A small number that is added to the weighted probabilities
##'   /before/ normalizing to get the responsibilities. Defaults to 1E-20.
##' @param first_iter \code{TRUE} if this is the first EM iteration, which is
##'   handled separately.
##' @param denslist_by_clust Pre-calculated densities.
##' @param countslist Counts or biomass.
##'
##' @return List of responsibility matrices, containing the posterior
##'   probabilities of the latent variable $Z$ (memberships to each cluster)
##'   given the parameter estimate. T-length list of (nt x dimdat)


Estep <- function(mn, sigma, prob, ylist = NULL,
                  censor_indicator_left ,
                  censor_indicator_right,
                  cens_lim_l_vec,
                  cens_lim_u_vec,
                  numclust,
                  denslist_by_clust = NULL,
                  first_iter = FALSE,
                  eps = 1E-20,
                  countslist = NULL){
  
  ## Setup
  TT = length(ylist)
  ntlist = sapply(ylist, nrow)
  dimdat = dim(mn)[2]
  
  ## Basic checks
  assertthat::assert_that(dim(mn)[1] == length(ylist))
  assertthat::assert_that(length(censor_indicator_left) == length(ylist))
  assertthat::assert_that(length(censor_indicator_right) == length(ylist))
  assertthat::assert_that(length(cens_lim_l_vec) == dimdat)
  assertthat::assert_that(length(cens_lim_u_vec) == dimdat)
  
  calculate_dens <- function(iclust, tt, y,
                             mn, sigma,  
                             censor_indicator_left_t, ##the left censoring indicator at time tt in the list
                             censor_indicator_right_t, ##the right censoring indicator at time tt in the list
                             cens_lim_l_vec,
                             cens_lim_u_vec,                             
                             denslist_by_clust, 
                             first_iter){
    mu <- mn[tt,,iclust] ## No problem with memory leak here.\
    nt=nrow(y)
    dens=numeric(nt)
    Sigma = sigma[iclust,,]
    
    if(first_iter){    
    for(ii in 1:nt){
      if(dimdat==1){
        dens[ii] = stats::dnorm(y, mu, sd = sqrt(sigma[iclust,,])) * (censor_indicator_left_t[ii,]!=1 |is.na(censor_indicator_left_t[ii,]))&(censor_indicator_right_t[ii,]!=1|is.na(censor_indicator_right_t[ii,])) +
                  pnorm(cens_lim_l_vec,mu,sd = sqrt(sigma[iclust,,]))*(censor_indicator_left_t[ii,]==1)+
                  (1-pnorm(cens_lim_u,mu,sqrt(sigma[iclust,,])))*(censor_indicator_right_t[ii,]==1)
          ## make sure to use standard deviation here!
      } else {
        left_cens_index = which((censor_indicator_left_t[ii,]==1) & (1-is.na(censor_indicator_left_t[ii,])))
        right_cens_index = which((censor_indicator_right_t[ii,]==1) & (1-is.na(censor_indicator_right_t[ii,])))
        uncensored_index=which((censor_indicator_left_t[ii,]!=1 |is.na(censor_indicator_left_t[ii,]))&(censor_indicator_right_t[ii,]!=1|is.na(censor_indicator_right_t[ii,])))
          lower_limits = cens_lim_l_vec[left_cens_index]
          upper_limits = cens_lim_u_vec[right_cens_index]
  
 #       debug(Cond_mean_var_func)
        res_cond = Cond_mean_var_func(y, mu,Sigma,uncensored_index)
        mu_conditional = res_cond$mu_conditional
        mu_observed = mu[uncensored_index]
        Sigma_conditional = res_cond$Sigma_conditional
        Sigma_observed = Sigma[uncensored_index,uncensored_index]
        y_observed = y[uncensored_index]
      
        if((length(upper_limits)>0)||(length(lower_limits)>0)){
        p_lower_limit = numeric(dimdat)
        p_upper_limit = numeric(dimdat)
        p_lower_limit[left_cens_index] = -Inf
        p_lower_limit[uncensored_index] = -Inf
        p_lower_limit[right_cens_index] = upper_limits
        p_upper_limit[left_cens_index] = lower_limits
        p_upper_limit[uncensored_index] = Inf
        p_upper_limit[right_cens_index] = Inf
        
        dens[ii] = dmvnorm_arma_fast(matrix(y_observed,1,length(y_observed)), mu_observed, as.matrix(Sigma_observed), FALSE) *  my_pmvnorm(p_lower_limit[sort(c(left_cens_index,right_cens_index))], p_upper_limit[sort(c(left_cens_index,right_cens_index))], mean = as.vector(mu_conditional), sigma = Sigma_conditional)[1]
    
        }else{
            dens[ii] = dmvnorm_arma_fast(y[ii,, drop=F], mu, as.matrix(sigma[iclust,,]), FALSE)
            
          }            
    
      }    
    }

    } else {
      dens = unlist(denslist_by_clust[[iclust]][[tt]])
    }
    return(dens)
  }
  
  
  ## Calculate the responsibilities at each time point, separately
  ncol.prob = ncol(prob)
  resp <- lapply(1:TT, function(tt){
    ylist_tt = ylist[[tt]]
    censor_indicator_left_t = censor_indicator_left[[tt]]
    censor_indicator_right_t = censor_indicator_right[[tt]]
    ntt = ntlist[tt]
    
    if(nrow(ylist_tt) == 0){
      return(ylist_tt)
    }
    
    ## Calculate the densities of data with respect to cluster centers
   # debug(calculate_dens)
    densmat <- sapply(1:numclust,
                      calculate_dens,
                      ## Rest of arguments:
                      tt, ylist_tt, mn, sigma,
                      censor_indicator_left_t, ##the left censoring indicator at time tt in the list
                      censor_indicator_right_t, ##the right censoring indicator at time tt in the list
                      cens_lim_l_vec,
                      cens_lim_u_vec,   
                      denslist_by_clust, first_iter)
    ## Weight them by prob, to produce responsibilities.
    wt.densmat <- matrix(prob[tt,], nrow = ntlist[tt], ncol = ncol.prob, byrow = TRUE) * densmat
    wt.densmat = wt.densmat + eps ## Add some small number to prevent ALL zeros.
    wt.densmat <- wt.densmat / rowSums(wt.densmat)
    
    ## If |countslist| is provided, reweight the responsibilities.
    if(!is.null(countslist)){
      wt.densmat = wt.densmat * countslist[[tt]]
    }
    return(wt.densmat)
  })
  
  return(resp)
}


#debug(Estep)
###NaNs here fix this

Estep(mn_array, sigma_array, pmat, ylist,
                  censor_indicator_left = cens_ind_left ,
                  censor_indicator_right = cens_ind_right,
                  cens_lim_l_vec = cens_vec_1,
                  cens_lim_u_vec = cens_vec_2,
                  numclust=2,
                  denslist_by_clust = NULL,
                  first_iter = TRUE,
                  eps = 1E-20,
                  countslist = NULL)


```











