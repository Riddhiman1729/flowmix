---
title: "M_step_Sigma"
author: "Riddhiman Bhattacharya"
date: "2025-10-22"
output: html_document
---
```{r}
library(abind)
```

```{r}
#'Function to assist in calculating the Sigmahat for the censored terms
#'@param resp.long_cens set of all censored responsibilities
#'@param first_mom.long_cens first censored moments of the censored observations as a long (ntxTT)xd matrix.
#'@param second_mom.long_cens second censored moments of the censored observations as a long (ntxTT)xdxd array.
#'@param mnlong_cens matrix of means in long form of size (ntxTT)xd. The entries in each tt is repeated.
#'@param resp.sum Sum of all the responsibilities 
#'
#'@return The censored residual matrix.

Sigma_hat_calculation_fn <- function(resp.long_cens,first_mom.long_cens,second_mom.long_cens,mnlong_cens,resp.sum){
  
  dimdat = ncol(first_mom.long_cens)
  cens.count = nrow(first_mom.long_cens)
  
  out_mat = matrix(0,dimdat,dimdat)

  for(i in 1:cens.count){
      out_mat= out_mat + resp.long_cens[i] (resp.long_cens[i,,] - first_mom.long_cens[i,] %*% t(mnlong_cens[i,]) - mnlong_cens[i,] %*% t(first_mom.long_cens[i,]) + mnlong_cens[i,] %*% t(mnlong_cens[i,]))
  }
  return(out/resp.sum)
}

```


```{r}
##' M-step for covariance matrix \eqn{\Sigma_k} for cluster \eqn{k} in 1 through
##' \code{numclust}.
##'
##' @param mn Fitted means.
##' @param resp Responsibilities.
##' @param ylist List of cytograms.
##' @param cens_mat matrix of all censoring
##' @param first_moment_list list of first moments conditioned on the observed data
##' @param second_moment_list list of second moments conditioned on the observed data
##' @param numclust Number of clusters.
##'
##' @return An array of size (numclust x dimdat x dimdat) containing the
##'   covariance matrices.
Mstep_sigma <- function(resp, ylist, cens_mat, first_moment_list, second_moment_list, mn, numclust){
#Sigma_hat_calculation_fn <- function(ii,tt,first_moment_list,second_moment_list,mu_list)
  ## Find some sizes
  TT = length(ylist)
  ntlist = sapply(ylist, nrow)
  dimdat = ncol(ylist[[1]])
  cs = c(0, cumsum(ntlist))
  irows.list = lapply(1:TT, function(tt){irows = (cs[tt] + 1):cs[tt + 1]})

  ## Set up empty residual matrix (to be reused)
  cs = c(0, cumsum(ntlist))
  vars <- vector(mode = "list", numclust)
  ylong = do.call(rbind, ylist)
  ntlist = sapply(ylist, nrow)
  irows = rep(1:nrow(mn), times = ntlist)
  cens_ind = 1*(apply(cens_mat[,-c(1,2)],1,sum)!=0)
  ylong_ncens = ylong[-cens_ind,]
  ylong_cens = ylong[cens_ind,]
  
  for(iclust in 1:numclust){
      resp.thisclust = lapply(resp, function(myresp) myresp[,iclust, drop = TRUE])
      resp.long = do.call(c, resp.thisclust)
      resp.long_ncens = resp.long[-cens_ind]
      resp.long_cens = resp.long[cens_ind]
      mnlong = mn[irows,,iclust]
      if(is.vector(mnlong)) mnlong = mnlong %>% cbind()
      mnlong_ncens = mnlong[-cens_ind,]
      mnlong_cens = mnlong[cens_ind,]
      first_mom.long = do.call(rbind,first_moment_list[[iclust]])
      second_mom.long = abind::abind(second_moment_list[[iclust]], along = 1)
      first_mom.long_cens = first_mom.long[cens_ind,]
      second_mom.long_cens = second_mom.long[cens_ind,,]
      vars[[iclust]] = estepC(ylong_ncens, mnlong_ncens, sqrt(resp.long_ncens), sum(resp.long)) + Sigma_hat_calculation_fn(resp.long_cens,first_mom.long_cens,second_mom.long_cens,mnlong_cens,sum(resp.long))

  }
  
  

  ## Make into an array
  sigma_array = array(NA, dim=c(numclust, dimdat, dimdat))
  for(iclust in 1:numclust){
      sigma_array[iclust,,] = vars[[iclust]]
  }

  ## Basic check
  stopifnot(all(dim(sigma_array) == c(numclust, dimdat, dimdat)))
  return(sigma_array)
}

##' Given a matrix positive definite matrix a, compute \eqn{a^{-1/2}}.  Only works for
##' positive semidefinite matrices that are diagonalizable (no normal Jordan
##' forms, etc.)
##'
##' @param a A PSD matrix.
##'
##' @return Matrix of the same size as \code{a}.
mtsqrt_inv <- function(a){
  a.eig <- eigen(a)

  ## In case vec is a single element, in which case diag() isn't quite right.
  vec = 1 / sqrt(a.eig$values)
  if(length(vec)==1){
    mat = vec
  } else {
    mat = diag(vec)
  }

  ## a.sqrt <- a.eig$vectors %*% diag(1 / sqrt(a.eig$values)) %*% t(a.eig$vectors)
  a.sqrt <- a.eig$vectors %*% mat %*% t(a.eig$vectors)
}

```

```{r}
left_cens_index_temp = list()
right_cens_index_temp = list()

TT=30

for(tt in 1:TT){
  left_cens_index_temp[[tt]] = cbind(rep(1,nrow(cens_ind_left[[tt]])), seq(1,nrow(cens_ind_left[[tt]]),1),cens_ind_left[[tt]])
  right_cens_index_temp[[tt]] = cbind(rep(1,nrow(cens_ind_right[[tt]])), seq(1,nrow(cens_ind_right[[tt]]),1),cens_ind_right[[tt]])
}

temp_mat_left = do.call(rbind, left_cens_index_temp)
temp_mat_right = do.call(rbind, right_cens_index_temp)

temp_mat_left[is.na(temp_mat_left)] = 0
temp_mat_right[is.na(temp_mat_right)] = 0

cens_mat = pmax(temp_mat_left,temp_mat_right)

```

```{r}
#mn_array, sigma_array

first_moment_list = estepy_saved$means

second_moment_list = estepy_saved$second_moments

debug(Mstep_sigma)

Mstep_sigma(resp, ylist, cens_mat, first_moment_list, second_moment_list, mn_array, numclust=2)

```



